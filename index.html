<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Warframe 1999 ‚Äî Dialog Route Guide</title>
<link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Rajdhani:wght@400;500;600;700&display=swap" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.26.9/babel.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body, #root { height: 100%; }
body { background: #08080c; color: #d4d4d8; font-family: 'Segoe UI', system-ui, sans-serif; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #27272a; border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: #3f3f46; }
@keyframes spin { to { transform: rotate(360deg); } }
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.step-card { animation: fadeIn 0.25s ease-out both; }
button { font-family: inherit; }
button:hover { filter: brightness(1.15); }

/* Mobile sidebar toggle */
@media (max-width: 768px) {
  .sidebar { position: fixed !important; left: -240px; z-index: 100; transition: left 0.25s ease; height: 100vh !important; }
  .sidebar.open { left: 0; }
  .sidebar-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 99; }
  .sidebar-overlay.open { display: block; }
  .mobile-toggle { display: flex !important; }
  .convo-panel { min-width: unset !important; width: 100% !important; border-right: none !important; max-height: 200px; }
  .main-layout { flex-direction: column !important; }
  .route-panel { padding: 16px 12px 80px !important; }
}
</style>
</head>
<body>
<div id="root"></div>
<script src="data.js" onerror="console.log('No local data.js found, using CORS proxy mode')"></script>
<script type="text/babel">
const { useState, useEffect, useCallback, useRef, useMemo } = React;

const BASE = "https://kim.browse.wf/flowcharts_svg/en/";
const CORS_PROXY = "https://corsproxy.io/?";
const LOCAL_DATA = window.WF1999_DATA || null;
const HAS_LOCAL = !!LOCAL_DATA;
const CHARACTERS = [
  { id: "Aoi", dir: "AoiDialogue_rom.dialogue", color: "#60a5fa", portrait: "‚ùÑÔ∏è" },
  { id: "Arthur", dir: "ArthurDialogue_rom.dialogue", color: "#f87171", portrait: "‚öîÔ∏è" },
  { id: "Eleanor", dir: "EleanorDialogue_rom.dialogue", color: "#c084fc", portrait: "üåô" },
  { id: "Flare", dir: "FlareDialogue_rom.dialogue", color: "#fb923c", portrait: "üî•" },
  { id: "Hex", dir: "HexDialogue_rom.dialogue", color: "#a78bfa", portrait: "üîÆ" },
  { id: "Jabir", dir: "JabirDialogue_rom.dialogue", color: "#34d399", portrait: "üß™" },
  { id: "Kaya", dir: "KayaDialogue_rom.dialogue", color: "#f472b6", portrait: "üéµ" },
  { id: "Lettie", dir: "LettieDialogue_rom.dialogue", color: "#fbbf24", portrait: "‚ú®" },
  { id: "Loid", dir: "LoidDialogue_rom.dialogue", color: "#94a3b8", portrait: "ü§ñ" },
  { id: "Lyon", dir: "LyonDialogue_rom.dialogue", color: "#2dd4bf", portrait: "üê∫" },
  { id: "Marie", dir: "MarieDialogue_rom.dialogue", color: "#e879f9", portrait: "üíú" },
  { id: "Minerva", dir: "MinervaDialogue_rom.dialogue", color: "#fca5a5", portrait: "ü¶Ö" },
  { id: "MinervaVelemir", dir: "MinervaVelemirDialogue_rom.dialogue", color: "#fca5a5", portrait: "ü¶Öüêª" },
  { id: "Quincy", dir: "QuincyDialogue_rom.dialogue", color: "#fb923c", portrait: "üéØ" },
  { id: "Roathe", dir: "RoatheDialogue_rom.dialogue", color: "#6ee7b7", portrait: "üåø" },
  { id: "Velemir", dir: "VelimirDialogue_rom.dialogue", color: "#a3a3a3", portrait: "üêª" },
];

/* ‚îÄ‚îÄ‚îÄ SVG PARSER ‚îÄ‚îÄ‚îÄ */
function parseSvg(svgText) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgText, "image/svg+xml");
  const nodes = {};
  const edges = [];

  doc.querySelectorAll("g.node").forEach((g) => {
    const title = g.querySelector("title")?.textContent?.trim();
    if (!title) return;
    const texts = [];
    g.querySelectorAll("text").forEach((t) => {
      const txt = t.textContent?.trim();
      if (txt) texts.push(txt);
    });
    const text = texts.join(" ").trim();
    const shape = g.querySelector("ellipse") || g.querySelector("polygon");
    const stroke = shape?.getAttribute("stroke") || "";
    let type = "dialog";
    if (stroke === "red") type = "choice";
    else if (stroke === "orange") type = "special";
    nodes[title] = { id: title, text, type, stroke };
  });

  doc.querySelectorAll("g.edge").forEach((g) => {
    const title = g.querySelector("title")?.textContent?.trim() || "";
    // Handle both raw -> and HTML-encoded &#45;>
    const cleaned = title.replace(/&#45;/g, "-").replace(/&#62;/g, ">");
    const m = cleaned.match(/^(.+?)-\>(.+)$/);
    if (!m) return;
    const from = m[1];
    const to = m[2];
    const path = g.querySelector("path");
    const edgeStroke = path?.getAttribute("stroke") || "black";
    let label = null;
    g.querySelectorAll("text").forEach((t) => {
      const val = t.textContent?.trim();
      if (val === "true" || val === "false") label = val;
    });
    edges.push({ from, to, stroke: edgeStroke, label });
  });

  return { nodes, edges };
}

/* ‚îÄ‚îÄ‚îÄ BEST PATH FINDER (DFS) ‚îÄ‚îÄ‚îÄ */
function extractChem(text) {
  const m = text?.match(/\+(\d+)\s*Chemistry/i);
  return m ? parseInt(m[1]) : 0;
}

function extractBoolName(text) {
  const m = text?.match(/^(?:Check boolean|Boolean)\s+(\S+)/);
  return m ? m[1] : null;
}

function findBestPath(nodes, edges, startId, booleans = {}) {
  const adj = {};
  for (const e of edges) {
    if (!adj[e.from]) adj[e.from] = [];
    adj[e.from].push(e);
  }

  let bestPath = null;
  let bestChem = -1;
  let iterations = 0;
  const MAX_ITER = 50000;

  function dfs(nodeId, path, chem, visited) {
    if (iterations++ > MAX_ITER) return;
    const node = nodes[nodeId];
    if (!node) return;

    // Prevent infinite loops but allow "Chat ends" revisits
    if (visited.has(nodeId) && !nodeId.includes("Chat ends")) return;

    const nodeChem = extractChem(node.text);
    const totalChem = chem + nodeChem;
    const newPath = [...path, { nodeId, text: node.text, type: node.type, chem: nodeChem }];

    const neighbors = adj[nodeId] || [];

    // Terminal conditions
    if (
      node.text?.includes("Chat ends") ||
      node.text?.match(/\[End\.?\]/) ||
      neighbors.length === 0
    ) {
      if (totalChem > bestChem) {
        bestChem = totalChem;
        bestPath = newPath;
      }
      return;
    }

    const newVisited = new Set(visited);
    newVisited.add(nodeId);

    // If this is a boolean check node and the user has set that boolean,
    // only follow the matching branch instead of exploring both
    const boolName = extractBoolName(node.text);
    let edgesToFollow = neighbors;
    if (boolName && boolName in booleans) {
      const want = booleans[boolName] ? "true" : "false";
      const filtered = neighbors.filter(e => e.label === want);
      if (filtered.length > 0) edgesToFollow = filtered;
    }

    for (const e of edgesToFollow) {
      dfs(e.to, newPath, totalChem, newVisited);
    }
  }

  dfs(startId, [], 0, new Set());
  return { path: bestPath || [], totalChem: Math.max(0, bestChem) };
}

/* ‚îÄ‚îÄ‚îÄ ANALYZE A FLOWCHART SVG ‚îÄ‚îÄ‚îÄ */
function analyzeFlowchart(svgText, booleans = {}) {
  const { nodes, edges } = parseSvg(svgText);

  // Collect all boolean condition names present in this flowchart
  const boolNames = [];
  for (const node of Object.values(nodes)) {
    const bn = extractBoolName(node.text);
    if (bn && !boolNames.includes(bn)) boolNames.push(bn);
  }

  const startNode = Object.keys(nodes).find((k) => k.includes("begins"));
  if (!startNode) return { steps: [], totalChem: 0, boolNames };

  const result = findBestPath(nodes, edges, startNode, booleans);

  // Build clean steps from the raw path
  const steps = [];
  for (const node of result.path) {
    if (
      node.text?.includes("Check boolean") ||
      node.text?.match(/^Boolean\s/) ||
      node.text?.includes("begins")
    ) continue;
    if (node.text === "Chat ends.") continue;

    if (node.type === "choice") {
      steps.push({ type: "choice", text: node.text, chem: node.chem });
    } else if (node.type === "special" && node.chem > 0) {
      steps.push({ type: "chem", text: node.text, chem: node.chem });
    } else if (node.type === "dialog") {
      steps.push({ type: "dialog", text: node.text, chem: node.chem });
    }
  }

  // Gather all alternatives at choice points
  const parentOfChoice = {};
  for (const e of edges) {
    const toNode = nodes[e.to];
    if (toNode?.type === "choice") {
      if (!parentOfChoice[e.from]) parentOfChoice[e.from] = [];
      parentOfChoice[e.from].push(toNode.text);
    }
  }
  // Also gather dialog siblings that are player-selectable
  for (const e of edges) {
    const fromNode = nodes[e.from];
    if (!fromNode) continue;
    const siblings = edges.filter(ee => ee.from === e.from);
    if (siblings.length > 1 && fromNode.type !== "special") {
      siblings.forEach(s => {
        const sn = nodes[s.to];
        if (sn?.type === "choice") {
          if (!parentOfChoice[e.from]) parentOfChoice[e.from] = [];
          if (!parentOfChoice[e.from].includes(sn.text)) parentOfChoice[e.from].push(sn.text);
        }
      });
    }
  }

  // Attach alternatives to choice steps
  const bestChoiceTexts = new Set(steps.filter(s => s.type === "choice").map(s => s.text));
  const enrichedSteps = steps.map((step, i) => {
    if (step.type !== "dialog") return step;
    // Find the next choice after this dialog
    const nextChoice = steps[i + 1];
    if (nextChoice?.type !== "choice") return step;
    // Find parent node
    const parentId = result.path.find(p => p.text === step.text)?.nodeId;
    if (!parentId) return step;
    const alts = (parentOfChoice[parentId] || []).filter(t => !bestChoiceTexts.has(t));
    // Calculate chemistry for each alternative branch so player can pick best available
    const enrichedAlts = alts.map(altText => {
      const altNodeId = Object.keys(nodes).find(k => nodes[k].text === altText);
      if (!altNodeId) return { text: altText, chem: null };
      const altResult = findBestPath(nodes, edges, altNodeId, booleans);
      return { text: altText, chem: altResult.totalChem };
    }).sort((a, b) => (b.chem ?? -1) - (a.chem ?? -1));
    return { ...step, alternatives: enrichedAlts };
  });

  return { steps: enrichedSteps, totalChem: result.totalChem, boolNames };
}

/* ‚îÄ‚îÄ‚îÄ UTILITIES ‚îÄ‚îÄ‚îÄ */
function normalizeSearch(s) {
  return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
}

function prettifyName(filename) {
  return filename.replace(/\.svg$/, "").replace(/([A-Z])/g, " $1").replace(/(\d+)/g, " $1 ").replace(/\s+/g, " ").trim();
}

function categorizeSvgs(files) {
  const ranks = {};
  const other = [];
  for (const f of files) {
    const m = f.match(/Rank(\d+)Convo(\d+)/);
    if (m) {
      const rank = parseInt(m[1]);
      if (!ranks[rank]) ranks[rank] = [];
      ranks[rank].push(f);
    } else {
      other.push(f);
    }
  }
  return { ranks, other };
}

/* ‚îÄ‚îÄ‚îÄ STATIC HELPERS (used during init before hooks) ‚îÄ‚îÄ‚îÄ */
function extractDialogTextStatic(svgText) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgText, "image/svg+xml");
  const lines = [];
  doc.querySelectorAll("g.node").forEach((g) => {
    const texts = [];
    g.querySelectorAll("text").forEach((t) => {
      const txt = t.textContent?.trim();
      if (txt) texts.push(txt);
    });
    const text = texts.join(" ").trim();
    if (text && !text.match(/^(Check boolean|Boolean )/)) lines.push(text);
  });
  return lines;
}

/* ‚îÄ‚îÄ‚îÄ MAIN APP ‚îÄ‚îÄ‚îÄ */
function App() {
  const [charIdx, setCharIdx] = useState(null);
  const [selectedFile, setSelectedFile] = useState(null);
  const [loading, setLoading] = useState(false);
  const [analysis, setAnalysis] = useState(null);
  const [error, setError] = useState(null);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [globalSearch, setGlobalSearch] = useState("");
  const [globalSearchDebounced, setGlobalSearchDebounced] = useState("");
  const globalDebounceRef = useRef(null);
  const [booleans, setBooleans] = useState({}); // { BoolName: true | false } ‚Äî undefined = AUTO
  const booleansRef = useRef({});
  const currentSvgRef = useRef(null); // stores the last loaded SVG for re-analysis on boolean change

  // Build initial cache from local data or localStorage
  const [cache, setCache] = useState(() => {
    if (HAS_LOCAL) {
      // Build full cache from bundled data.js ‚Äî instant, no network
      const c = {};
      for (const character of CHARACTERS) {
        const d = LOCAL_DATA[character.dir];
        if (!d) continue;
        const index = {};
        const indexLower = {};
        for (const [file, svgText] of Object.entries(d.svgs || {})) {
          const lines = extractDialogTextStatic(svgText);
          index[file] = lines;
          indexLower[file] = lines.map(normalizeSearch);
        }
        c[character.dir] = { files: d.files || [], svgs: d.svgs || {}, index, indexLower };
      }
      return c;
    }
    try {
      const saved = localStorage.getItem("wf1999_cache_v3");
      return saved ? JSON.parse(saved) : {};
    } catch { return {}; }
  });
  const cacheRef = useRef(cache);
  useEffect(() => { cacheRef.current = cache; }, [cache]);

  const [globalProgress, setGlobalProgress] = useState({ char: "", done: 0, total: 0 });
  const [isPreloading, setIsPreloading] = useState(false);

  const char = charIdx !== null ? CHARACTERS[charIdx] : null;
  const accentColor = char?.color || "#71717a";
  const charCache = char ? cache[char.dir] : null;
  const convoFiles = charCache?.files || [];

  // Persist cache to localStorage (only in network mode)
  const saveTimerRef = useRef(null);
  useEffect(() => {
    if (HAS_LOCAL) return; // no need to cache, we have bundled data
    if (saveTimerRef.current) clearTimeout(saveTimerRef.current);
    saveTimerRef.current = setTimeout(() => {
      try { localStorage.setItem("wf1999_cache_v3", JSON.stringify(cache)); } catch {}
    }, 1000);
  }, [cache]);

  // Use the static helper
  const extractDialogText = extractDialogTextStatic;

  // Fetch file list for one character
  const fetchCharFiles = async (character) => {
    const url = CORS_PROXY + encodeURIComponent(BASE + character.dir + "/");
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const html = await res.text();
    const matches = [...html.matchAll(/href="([^"]*\.svg)"/gi)];
    return matches.map((m) => m[1]).sort();
  };

  // Preload ALL characters on mount (skip if local data bundled)
  useEffect(() => {
    if (HAS_LOCAL) return; // everything already loaded from data.js
    let cancelled = false;

    const isCharCached = (dir) => {
      const cc = cacheRef.current[dir];
      return cc?.files?.length > 0 && cc?.index && Object.keys(cc.index).length >= cc.files.length;
    };

    const indexOneCharacter = async (character) => {
      if (isCharCached(character.dir)) return;

      // 1. Get file list
      let files;
      const existing = cacheRef.current[character.dir];
      if (existing?.files?.length > 0) {
        files = existing.files;
      } else {
        files = await fetchCharFiles(character);
        if (files.length === 0) return;
        // Save file list immediately so UI can show it
        setCache(prev => {
          const next = { ...prev, [character.dir]: { ...prev[character.dir], files } };
          cacheRef.current = next;
          return next;
        });
      }

      // 2. Fetch all SVGs in parallel batches
      const idx = {};
      const idxLower = {};
      let done = 0;
      const BATCH = 12;

      for (let i = 0; i < files.length; i += BATCH) {
        if (cancelled) return;
        const batch = files.slice(i, i + BATCH);
        const results = await Promise.allSettled(
          batch.map(async (f) => {
            const url = CORS_PROXY + encodeURIComponent(BASE + character.dir + "/" + f);
            const r = await fetch(url);
            return { file: f, text: await r.text() };
          })
        );
        for (const r of results) {
          if (r.status === "fulfilled") {
            const lines = extractDialogText(r.value.text);
            idx[r.value.file] = lines;
            idxLower[r.value.file] = lines.map(normalizeSearch);
          }
        }
        done += batch.length;
        if (!cancelled) {
          setGlobalProgress({ char: character.id, done: Math.min(done, files.length), total: files.length });
        }
      }

      if (!cancelled) {
        setCache(prev => {
          const next = { ...prev, [character.dir]: { files, index: idx, indexLower: idxLower } };
          cacheRef.current = next;
          return next;
        });
      }
    };

    // Check if anything needs caching
    const needsCaching = CHARACTERS.some(c => !isCharCached(c.dir));
    if (!needsCaching) return;

    setIsPreloading(true);
    (async () => {
      for (const character of CHARACTERS) {
        if (cancelled) break;
        if (isCharCached(character.dir)) continue;
        setGlobalProgress({ char: character.id, done: 0, total: 0 });
        try {
          await indexOneCharacter(character);
        } catch {
          // Skip failed, continue with next
        }
      }
      if (!cancelled) setIsPreloading(false);
    })();

    return () => { cancelled = true; };
  }, []); // runs once on mount


  // Fetch and analyze one SVG for route display
  const fetchAndAnalyze = useCallback(async (filename) => {
    if (!char) return;
    setLoading(true);
    setAnalysis(null);
    setError(null);
    try {
      let svgText;
      // Use local bundled SVG if available
      const localSvg = cache[char.dir]?.svgs?.[filename];
      if (localSvg) {
        svgText = localSvg;
      } else {
        const url = CORS_PROXY + encodeURIComponent(BASE + char.dir + "/" + filename);
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        svgText = await res.text();
      }
      currentSvgRef.current = svgText;
      const result = analyzeFlowchart(svgText, booleansRef.current);
      setAnalysis(result);
    } catch (e) {
      setError("Failed to load: " + e.message);
    }
    setLoading(false);
  }, [char, cache]);

  // If selected character has no cached files and preloader isn't running, fetch file list
  useEffect(() => {
    if (HAS_LOCAL) return; // already have everything
    if (!char) return;
    if (charCache?.files?.length) return;
    if (isPreloading) return;
    fetchCharFiles(char).then(files => {
      if (files.length > 0) {
        setCache(prev => {
          const next = { ...prev, [char.dir]: { ...prev[char.dir], files } };
          cacheRef.current = next;
          return next;
        });
      }
    }).catch(() => {});
  }, [char, isPreloading]);

  // Debounce global search (200ms)
  useEffect(() => {
    if (globalDebounceRef.current) clearTimeout(globalDebounceRef.current);
    globalDebounceRef.current = setTimeout(() => setGlobalSearchDebounced(globalSearch), 200);
    return () => { if (globalDebounceRef.current) clearTimeout(globalDebounceRef.current); };
  }, [globalSearch]);

  // Keep booleansRef in sync with state
  useEffect(() => { booleansRef.current = booleans; }, [booleans]);

  // Re-analyze the current flowchart whenever boolean conditions change
  useEffect(() => {
    if (currentSvgRef.current) {
      setAnalysis(analyzeFlowchart(currentSvgRef.current, booleans));
    }
  }, [booleans]);

  // Global search across all characters
  const globalResults = useMemo(() => {
    if (!globalSearchDebounced.trim()) return null;
    const q = normalizeSearch(globalSearchDebounced);
    const results = [];
    for (const character of CHARACTERS) {
      const cc = cache[character.dir];
      if (!cc?.indexLower) continue;
      const matches = [];
      for (const file of (cc.files || [])) {
        const nameMatch = normalizeSearch(prettifyName(file)).includes(q);
        const lines = cc.indexLower[file] || [];
        const lineIdx = lines.findIndex(l => l.includes(q));
        if (nameMatch || lineIdx >= 0) {
          const snippet = lineIdx >= 0 ? cc.index[file][lineIdx] : null;
          matches.push({ file, snippet });
        }
      }
      if (matches.length > 0) results.push({ character, matches });
    }
    return results;
  }, [globalSearchDebounced, cache]);

  // Fetch and analyze a specific character's SVG (doesn't depend on char state)
  const fetchAndAnalyzeFor = useCallback(async (charDir, filename) => {
    setLoading(true);
    setAnalysis(null);
    setError(null);
    try {
      let svgText;
      const localSvg = cache[charDir]?.svgs?.[filename];
      if (localSvg) {
        svgText = localSvg;
      } else {
        const url = CORS_PROXY + encodeURIComponent(BASE + charDir + "/" + filename);
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        svgText = await res.text();
      }
      currentSvgRef.current = svgText;
      setAnalysis(analyzeFlowchart(svgText, booleansRef.current));
    } catch (e) {
      setError("Failed to load: " + e.message);
    }
    setLoading(false);
  }, [cache]);

  const { ranks, other } = categorizeSvgs(convoFiles);

  return (
    <div style={{ display: "flex", height: "100vh", overflow: "hidden" }}>

      {/* Mobile overlay */}
      <div className={`sidebar-overlay ${sidebarOpen ? "open" : ""}`} onClick={() => setSidebarOpen(false)} />

      {/* Sidebar */}
      <aside className={`sidebar ${sidebarOpen ? "open" : ""}`} style={{
        width: 220, minWidth: 220, borderRight: "1px solid #1a1a24", background: "#0c0c14",
        display: "flex", flexDirection: "column", overflow: "hidden",
      }}>
        <div style={{ padding: "16px 14px 12px", borderBottom: "1px solid #1a1a24" }}>
          <div style={{ fontSize: 9, letterSpacing: 4, color: "#52525b", fontFamily: "'Rajdhani', monospace", textTransform: "uppercase" }}>Warframe 1999</div>
          <div style={{ fontSize: 15, fontWeight: 700, fontFamily: "'Chakra Petch', monospace", color: "#e4e4e7", letterSpacing: 1, marginTop: 2 }}>ROUTE GUIDE</div>
        </div>

        {/* Global search bar */}
        <div style={{ padding: "8px 10px 6px", borderBottom: "1px solid #1a1a24" }}>
          <div style={{ position: "relative" }}>
            <input
              type="text"
              placeholder="Search all characters..."
              value={globalSearch}
              onChange={e => setGlobalSearch(e.target.value)}
              style={{
                width: "100%", padding: "7px 10px 7px 28px", borderRadius: 6,
                border: `1px solid ${globalSearch ? "#60a5fa44" : "#1a1a24"}`,
                background: "#08080c", color: "#d4d4d8", fontSize: 11,
                fontFamily: "'Rajdhani', sans-serif", outline: "none", transition: "border-color 0.15s",
              }}
              onFocus={e => e.target.style.borderColor = "#60a5fa66"}
              onBlur={e => e.target.style.borderColor = globalSearch ? "#60a5fa44" : "#1a1a24"}
            />
            <span style={{ position: "absolute", left: 9, top: "50%", transform: "translateY(-50%)", fontSize: 11, opacity: 0.3, pointerEvents: "none" }}>üîç</span>
            {globalSearch && (
              <button onClick={() => { setGlobalSearch(""); setGlobalSearchDebounced(""); }} style={{
                position: "absolute", right: 6, top: "50%", transform: "translateY(-50%)",
                background: "none", border: "none", color: "#52525b", cursor: "pointer", fontSize: 14, padding: 2,
              }}>√ó</button>
            )}
          </div>
          {globalSearchDebounced && globalResults !== null && (
            <div style={{ marginTop: 4, fontSize: 10, color: "#52525b", fontFamily: "'Rajdhani', monospace" }}>
              {globalResults.length === 0
                ? "No results"
                : `${globalResults.reduce((a, r) => a + r.matches.length, 0)} results ¬∑ ${globalResults.length} character${globalResults.length !== 1 ? "s" : ""}`}
            </div>
          )}
        </div>

        <div style={{ flex: 1, overflowY: "auto", padding: "8px 6px" }}>
          {CHARACTERS.map((c, i) => {
            const active = charIdx === i;
            return (
              <button key={c.id} onClick={() => {
                setCharIdx(i); setSelectedFile(null); setAnalysis(null); setError(null); setSidebarOpen(false);
                currentSvgRef.current = null;
              }} style={{
                display: "flex", alignItems: "center", gap: 8, width: "100%",
                padding: "8px 10px", marginBottom: 2, borderRadius: 6, border: "none",
                background: active ? `${c.color}15` : "transparent",
                color: active ? c.color : "#71717a", cursor: "pointer",
                fontFamily: "'Rajdhani', sans-serif", fontSize: 13, fontWeight: active ? 600 : 400,
                textAlign: "left", transition: "all 0.15s",
                borderLeft: active ? `2px solid ${c.color}` : "2px solid transparent",
              }}>
                <span style={{ fontSize: 14 }}>{c.portrait}</span>
                <span style={{ flex: 1 }}>{c.id}</span>
                {cache[c.dir]?.index && <span style={{ fontSize: 8, color: "#4ade80", opacity: 0.6 }}>‚óè</span>}
                {isPreloading && globalProgress.char === c.id && <div style={{ width: 6, height: 6, border: "1.5px solid #60a5fa44", borderTopColor: "#60a5fa", borderRadius: "50%", animation: "spin 0.6s linear infinite" }} />}
              </button>
            );
          })}
        </div>
        <div style={{ padding: "10px", borderTop: "1px solid #1a1a24" }}>
          {/* Global preload status */}
          {HAS_LOCAL && (
            <div style={{ marginBottom: 8, padding: "6px 8px", background: "#052e1611", border: "1px solid #16a34a33", borderRadius: 6, fontSize: 10, color: "#4ade80", fontFamily: "'Rajdhani', monospace" }}>
              ‚ö° Local data ¬∑ instant mode
            </div>
          )}
          {!HAS_LOCAL && isPreloading && (
            <div style={{ marginBottom: 8, padding: "6px 8px", background: "#0f172a", border: "1px solid #1e3a5f", borderRadius: 6, fontSize: 10, color: "#60a5fa", fontFamily: "'Rajdhani', monospace", display: "flex", alignItems: "center", gap: 6 }}>
              <div style={{ width: 8, height: 8, border: "2px solid #60a5fa44", borderTopColor: "#60a5fa", borderRadius: "50%", animation: "spin 0.6s linear infinite", flexShrink: 0 }} />
              Caching {globalProgress.char}... {globalProgress.done}/{globalProgress.total}
            </div>
          )}
          {!HAS_LOCAL && !isPreloading && Object.keys(cache).length > 0 && (
            <div style={{ marginBottom: 8, padding: "6px 8px", background: "#052e1611", border: "1px solid #16a34a33", borderRadius: 6, fontSize: 10, color: "#4ade80", fontFamily: "'Rajdhani', monospace", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <span>‚úì {Object.keys(cache).length}/{CHARACTERS.length} cached</span>
              <button onClick={() => { localStorage.removeItem("wf1999_cache_v3"); setCache({}); cacheRef.current = {}; location.reload(); }} style={{
                background: "none", border: "none", color: "#52525b", cursor: "pointer", fontSize: 9, fontFamily: "'Rajdhani', monospace", textDecoration: "underline",
              }}>Clear</button>
            </div>
          )}
        </div>
      </aside>

      {/* Main content */}
      <main style={{ flex: 1, overflowY: "auto", display: "flex", flexDirection: "column" }}>

        {/* Mobile hamburger */}
        <button className="mobile-toggle" onClick={() => setSidebarOpen(true)} style={{
          display: "none", position: "fixed", top: 10, left: 10, zIndex: 98,
          width: 36, height: 36, borderRadius: 8, border: "1px solid #27272a",
          background: "#0c0c14", color: "#71717a", cursor: "pointer",
          alignItems: "center", justifyContent: "center", fontSize: 18,
        }}>‚ò∞</button>

        {globalSearchDebounced.trim() ? (
          /* ‚îÄ‚îÄ Global search results ‚îÄ‚îÄ */
          <div style={{ flex: 1, overflowY: "auto", padding: "20px 24px 80px" }}>
            <div style={{ fontSize: 11, color: "#52525b", fontFamily: "'Rajdhani', monospace", letterSpacing: 2, marginBottom: 20 }}>
              {globalResults && globalResults.length > 0
                ? `${globalResults.reduce((a, r) => a + r.matches.length, 0)} RESULTS ACROSS ${globalResults.length} CHARACTER${globalResults.length !== 1 ? "S" : ""}`
                : `NO RESULTS FOR "${globalSearchDebounced}"`}
            </div>
            {globalResults && globalResults.map(({ character, matches }) => (
              <div key={character.id} style={{ marginBottom: 28 }}>
                <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8, paddingBottom: 8, borderBottom: `1px solid ${character.color}22` }}>
                  <span style={{ fontSize: 16 }}>{character.portrait}</span>
                  <span style={{ fontFamily: "'Chakra Petch', monospace", fontWeight: 700, fontSize: 14, color: character.color }}>{character.id}</span>
                  <span style={{ fontSize: 10, color: "#52525b", fontFamily: "'Rajdhani', monospace" }}>{matches.length} match{matches.length !== 1 ? "es" : ""}</span>
                </div>
                {matches.slice(0, 8).map(({ file, snippet }) => {
                  const q = globalSearchDebounced.toLowerCase();
                  const convoNum = file.match(/Convo(\d+)/)?.[1];
                  const label = convoNum ? `Conversation ${convoNum}` : prettifyName(file);
                  return (
                    <button key={file} onClick={() => {
                      const idx = CHARACTERS.findIndex(c => c.id === character.id);
                      setCharIdx(idx);
                      setSelectedFile(file);
                      setGlobalSearch(""); setGlobalSearchDebounced("");
                      fetchAndAnalyzeFor(character.dir, file);
                    }} style={{
                      display: "block", width: "100%", padding: "8px 12px", marginBottom: 4,
                      borderRadius: 6, border: `1px solid ${character.color}18`,
                      background: `${character.color}08`, textAlign: "left", cursor: "pointer",
                    }}>
                      <div style={{ fontFamily: "'Rajdhani', sans-serif", fontWeight: 600, fontSize: 12, color: character.color }}>{label}</div>
                      {snippet && (() => {
                        const idx = snippet.toLowerCase().indexOf(q);
                        const start = Math.max(0, idx - 30);
                        const raw = (start > 0 ? "‚Ä¶" : "") + snippet.slice(start, start + 80) + (start + 80 < snippet.length ? "‚Ä¶" : "");
                        const sIdx = raw.toLowerCase().indexOf(q);
                        return (
                          <div style={{ fontSize: 11, color: "#52525b", marginTop: 3, fontFamily: "'Rajdhani', sans-serif", lineHeight: 1.4 }}>
                            "{sIdx >= 0 ? (
                              <>{raw.slice(0, sIdx)}<span style={{ color: character.color, fontWeight: 600 }}>{raw.slice(sIdx, sIdx + q.length)}</span>{raw.slice(sIdx + q.length)}</>
                            ) : raw}"
                          </div>
                        );
                      })()}
                    </button>
                  );
                })}
                {matches.length > 8 && (
                  <div style={{ fontSize: 10, color: "#3f3f46", fontFamily: "'Rajdhani', monospace", padding: "4px 12px" }}>
                    +{matches.length - 8} more ‚Äî refine your search to narrow results
                  </div>
                )}
              </div>
            ))}
          </div>
        ) : !char ? (
          <div style={{ flex: 1, display: "flex", alignItems: "center", justifyContent: "center", flexDirection: "column", gap: 12, opacity: 0.4 }}>
            <div style={{ fontSize: 48 }}>‚öóÔ∏è</div>
            <div style={{ fontSize: 14, fontFamily: "'Rajdhani', monospace", letterSpacing: 2 }}>SELECT A CHARACTER</div>
          </div>
        ) : (
          <>
            {/* Character header */}
            <div style={{ padding: "20px 24px 16px", borderBottom: "1px solid #1a1a24", background: `linear-gradient(135deg, ${accentColor}08, transparent)` }}>
              <div style={{ fontSize: 22, fontWeight: 700, fontFamily: "'Chakra Petch', monospace", color: accentColor }}>
                {char.portrait} {char.id}
              </div>
              <div style={{ fontSize: 12, color: "#52525b", fontFamily: "'Rajdhani', monospace", marginTop: 2 }}>
                {convoFiles.length > 0 ? `${convoFiles.length} conversations` + (charCache?.index ? " ¬∑ indexed ‚úì" : "") : isPreloading ? "Indexing in background..." : "Loading..."}
              </div>
            </div>

            <div className="main-layout" style={{ display: "flex", flex: 1, minHeight: 0 }}>
              {/* Conversation list */}
              <div className="convo-panel" style={{ width: 240, minWidth: 240, borderRight: "1px solid #1a1a24", overflowY: "auto", padding: "8px", display: "flex", flexDirection: "column" }}>
                {/* Indexing progress */}
                {isPreloading && globalProgress.char === char?.id && (
                  <div style={{ padding: "4px 0 8px", borderBottom: "1px solid #1a1a24", marginBottom: 8, flexShrink: 0 }}>
                    <div style={{ fontSize: 10, color: "#52525b", fontFamily: "'Rajdhani', monospace", display: "flex", alignItems: "center", gap: 6 }}>
                      <div style={{ width: 10, height: 10, border: `2px solid ${accentColor}44`, borderTopColor: accentColor, borderRadius: "50%", animation: "spin 0.6s linear infinite", flexShrink: 0 }} />
                      Indexing {globalProgress.done}/{globalProgress.total}...
                    </div>
                  </div>
                )}

                <div style={{ flex: 1, overflowY: "auto" }}>
                {!convoFiles.length && !isPreloading && <div style={{ padding: 16, textAlign: "center", color: "#52525b", fontSize: 12 }}>Loading file list...</div>}
                {!convoFiles.length && isPreloading && (
                  <div style={{ padding: 16, textAlign: "center", color: "#52525b", fontSize: 12, fontFamily: "'Rajdhani', monospace", display: "flex", flexDirection: "column", alignItems: "center", gap: 8 }}>
                    <div style={{ width: 16, height: 16, border: `2px solid ${accentColor}44`, borderTopColor: accentColor, borderRadius: "50%", animation: "spin 0.6s linear infinite" }} />
                    Waiting for background indexer...
                  </div>
                )}

                {(() => {
                  const renderConvoButton = (f) => {
                    const active = selectedFile === f;
                    const convoNum = f.match(/Convo(\d+)/)?.[1];
                    return (
                      <button key={f} onClick={() => { setSelectedFile(f); fetchAndAnalyze(f); }} style={{
                        display: "block", width: "100%", padding: "7px 10px", marginBottom: 2,
                        borderRadius: 5, border: "none", textAlign: "left", cursor: "pointer",
                        background: active ? `${accentColor}18` : "transparent",
                        color: active ? accentColor : "#71717a",
                        fontFamily: "'Rajdhani', sans-serif", fontSize: 12, fontWeight: active ? 600 : 400,
                      }}>
                        {convoNum ? `Conversation ${convoNum}` : prettifyName(f)}
                      </button>
                    );
                  };

                  return (
                    <>
                      {Object.entries(ranks).sort(([a],[b]) => a - b).map(([rank, files]) => (
                        <div key={rank} style={{ marginBottom: 12 }}>
                          <div style={{ fontSize: 10, letterSpacing: 3, color: "#3f3f46", fontFamily: "'Rajdhani', monospace", padding: "4px 8px", textTransform: "uppercase" }}>Rank {rank}</div>
                          {files.sort().map(renderConvoButton)}
                        </div>
                      ))}
                      {other.length > 0 && (
                        <div style={{ marginBottom: 12 }}>
                          <div style={{ fontSize: 10, letterSpacing: 3, color: "#3f3f46", fontFamily: "'Rajdhani', monospace", padding: "4px 8px" }}>OTHER</div>
                          {other.sort().map(renderConvoButton)}
                        </div>
                      )}
                    </>
                  );
                })()}
                </div>
              </div>

              {/* Route display */}
              <div className="route-panel" style={{ flex: 1, overflowY: "auto", padding: "20px 24px 80px" }}>
                {loading && (
                  <div style={{ display: "flex", alignItems: "center", justifyContent: "center", padding: 60, flexDirection: "column", gap: 12 }}>
                    <div style={{ width: 24, height: 24, border: `2px solid ${accentColor}44`, borderTopColor: accentColor, borderRadius: "50%", animation: "spin 0.6s linear infinite" }} />
                    <div style={{ fontSize: 12, color: "#52525b", fontFamily: "'Rajdhani', monospace" }}>Parsing flowchart...</div>
                  </div>
                )}

                {error && !loading && (
                  <div style={{ padding: "16px", background: "#1c1917", border: "1px solid #44403c", borderRadius: 8, color: "#fbbf24", fontSize: 13, lineHeight: 1.6 }}>
                    ‚ö†Ô∏è {error}
                  </div>
                )}

                {!loading && !analysis && !error && (
                  <div style={{ flex: 1, display: "flex", alignItems: "center", justifyContent: "center", flexDirection: "column", gap: 8, opacity: 0.3, paddingTop: 80 }}>
                    <div style={{ fontSize: 32 }}>üí¨</div>
                    <div style={{ fontSize: 12, fontFamily: "'Rajdhani', monospace", letterSpacing: 2 }}>
                      PICK A CONVERSATION
                    </div>
                  </div>
                )}

                {analysis && !loading && (
                  <>
                    {/* Route header */}
                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 20, flexWrap: "wrap", gap: 12 }}>
                      <div>
                        <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Chakra Petch', monospace", color: "#e4e4e7" }}>
                          {prettifyName(selectedFile || "")}
                        </div>
                        <div style={{ fontSize: 11, color: "#52525b", fontFamily: "'Rajdhani', monospace", marginTop: 2 }}>
                          {analysis.steps?.length || 0} steps ¬∑ optimal route
                        </div>
                      </div>
                      <div style={{
                        display: "flex", alignItems: "center", gap: 6,
                        background: analysis.totalChem > 0 ? "linear-gradient(135deg, #16a34a22, #16a34a11)" : "#1a1a2411",
                        border: `1px solid ${analysis.totalChem > 0 ? "#16a34a44" : "#27272a"}`,
                        padding: "8px 14px", borderRadius: 8,
                      }}>
                        <span style={{ fontSize: 10, color: analysis.totalChem > 0 ? "#86efac" : "#52525b", fontFamily: "'Rajdhani', monospace", letterSpacing: 1 }}>MAX</span>
                        <span style={{ fontSize: 22, fontWeight: 700, color: analysis.totalChem > 0 ? "#4ade80" : "#52525b", fontFamily: "'Chakra Petch', monospace" }}>
                          +{analysis.totalChem}
                        </span>
                        <span>‚öóÔ∏è</span>
                      </div>
                    </div>

                    {/* Boolean conditions panel */}
                    {analysis.boolNames?.length > 0 && (
                      <div style={{ marginBottom: 20, padding: "12px 14px", background: "#08080e", border: "1px solid #1e293b", borderRadius: 8 }}>
                        <div style={{ fontSize: 9, letterSpacing: 3, color: "#52525b", fontFamily: "'Rajdhani', monospace", marginBottom: 10 }}>
                          CONDITIONAL ROUTES ‚Äî set to match your game
                        </div>
                        {analysis.boolNames.map(boolName => {
                          const isTrue = booleans[boolName] === true;
                          const isFalse = booleans[boolName] === false;
                          const isAuto = !(boolName in booleans);
                          return (
                            <div key={boolName} style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 8, gap: 8 }}>
                              <div style={{ fontSize: 11, color: "#71717a", fontFamily: "'Rajdhani', sans-serif", lineHeight: 1.3 }}>
                                {boolName.replace(/([A-Z])/g, ' $1').trim()}
                              </div>
                              <div style={{ display: "flex", gap: 3, flexShrink: 0 }}>
                                <button onClick={() => setBooleans(prev => ({ ...prev, [boolName]: true }))} style={{
                                  padding: "2px 8px", fontSize: 9, fontFamily: "'Rajdhani', monospace", fontWeight: 700,
                                  letterSpacing: 1, borderRadius: 3, border: `1px solid ${isTrue ? "#22c55e" : "#27272a"}`,
                                  cursor: "pointer", background: isTrue ? "#16a34a22" : "transparent",
                                  color: isTrue ? "#4ade80" : "#52525b",
                                }}>YES</button>
                                <button onClick={() => setBooleans(prev => { const n = { ...prev }; delete n[boolName]; return n; })} style={{
                                  padding: "2px 8px", fontSize: 9, fontFamily: "'Rajdhani', monospace", fontWeight: 700,
                                  letterSpacing: 1, borderRadius: 3, border: `1px solid ${isAuto ? "#60a5fa" : "#27272a"}`,
                                  cursor: "pointer", background: isAuto ? "#60a5fa22" : "transparent",
                                  color: isAuto ? "#93c5fd" : "#52525b",
                                }}>AUTO</button>
                                <button onClick={() => setBooleans(prev => ({ ...prev, [boolName]: false }))} style={{
                                  padding: "2px 8px", fontSize: 9, fontFamily: "'Rajdhani', monospace", fontWeight: 700,
                                  letterSpacing: 1, borderRadius: 3, border: `1px solid ${isFalse ? "#ef4444" : "#27272a"}`,
                                  cursor: "pointer", background: isFalse ? "#dc262622" : "transparent",
                                  color: isFalse ? "#f87171" : "#52525b",
                                }}>NO</button>
                              </div>
                            </div>
                          );
                        })}
                        <div style={{ fontSize: 9, color: "#3f3f46", fontFamily: "'Rajdhani', monospace", marginTop: 6 }}>
                          AUTO picks the highest chemistry branch ¬∑ YES/NO locks to your game state
                        </div>
                      </div>
                    )}

                    {/* Steps timeline */}
                    {analysis.steps?.map((step, i) => {
                      const isChoice = step.type === "choice";
                      const isChem = step.type === "chem";

                      if (isChem) {
                        return (
                          <div key={i} className="step-card" style={{ animationDelay: `${i * 0.03}s`, display: "flex", alignItems: "center", gap: 8, padding: "8px 0 8px 32px", position: "relative" }}>
                            {i < analysis.steps.length - 1 && <div style={{ position: "absolute", left: 14, top: 0, bottom: 0, width: 1, background: `${accentColor}22` }} />}
                            <div style={{ position: "absolute", left: 9, top: "50%", transform: "translateY(-50%)", width: 11, height: 11, borderRadius: "50%", background: "#16a34a44", border: "2px solid #22c55e" }} />
                            <span style={{
                              display: "inline-flex", alignItems: "center", gap: 4,
                              background: "linear-gradient(135deg, #16a34a, #22c55e)",
                              color: "#fff", fontWeight: 700, fontSize: 12,
                              padding: "4px 12px", borderRadius: 99, fontFamily: "'Chakra Petch', monospace",
                            }}>
                              +{step.chem} Chemistry ‚öóÔ∏è
                            </span>
                          </div>
                        );
                      }

                      return (
                        <div key={i} className="step-card" style={{ animationDelay: `${i * 0.03}s`, position: "relative", paddingLeft: 32, marginBottom: 6 }}>
                          {i < analysis.steps.length - 1 && <div style={{ position: "absolute", left: 14, top: 24, bottom: 0, width: 1, background: `${accentColor}22` }} />}
                          <div style={{
                            position: "absolute", left: 8, top: 14, width: 13, height: 13, borderRadius: "50%",
                            background: isChoice ? `${accentColor}33` : "#18181b",
                            border: `2px solid ${isChoice ? accentColor : "#3f3f46"}`,
                          }} />
                          <div style={{
                            background: isChoice ? `${accentColor}0a` : "rgba(255,255,255,0.015)",
                            border: `1px solid ${isChoice ? `${accentColor}30` : "rgba(255,255,255,0.04)"}`,
                            borderRadius: 8, padding: "10px 14px",
                          }}>
                            <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 4, flexWrap: "wrap" }}>
                              {isChoice ? (
                                <span style={{
                                  background: accentColor, color: "#0a0a0f", fontSize: 9, fontWeight: 700,
                                  padding: "1px 6px", borderRadius: 3, letterSpacing: 1, fontFamily: "'Rajdhani', monospace",
                                }}>PICK THIS</span>
                              ) : (
                                <span style={{ fontSize: 9, letterSpacing: 2, color: "#3f3f46", fontFamily: "'Rajdhani', monospace" }}>
                                  {char.id.toUpperCase()}
                                </span>
                              )}
                              {step.chem > 0 && (
                                <span style={{
                                  display: "inline-flex", alignItems: "center", gap: 3,
                                  background: "linear-gradient(135deg, #16a34a, #22c55e)",
                                  color: "#fff", fontWeight: 700, fontSize: 10,
                                  padding: "1px 7px", borderRadius: 99,
                                }}>+{step.chem} ‚öóÔ∏è</span>
                              )}
                            </div>
                            <div style={{
                              fontSize: 13, lineHeight: 1.6, fontFamily: "'Rajdhani', sans-serif", fontWeight: 500,
                              color: isChoice ? "#e4e4e7" : "#a1a1aa",
                              borderLeft: isChoice ? "none" : `2px solid ${accentColor}22`,
                              paddingLeft: isChoice ? 0 : 10,
                            }}>
                              "{step.text}"
                            </div>

                            {/* Show alternatives with chemistry ‚Äî sorted best-first so player can pick best available */}
                            {step.alternatives?.length > 0 && (
                              <div style={{ marginTop: 8, paddingTop: 8, borderTop: "1px solid rgba(255,255,255,0.04)" }}>
                                <div style={{ fontSize: 9, letterSpacing: 2, color: "#52525b", fontFamily: "'Rajdhani', monospace", marginBottom: 4 }}>IF UNAVAILABLE, PICK IN ORDER:</div>
                                {step.alternatives.map((alt, ai) => (
                                  <div key={ai} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "4px 8px", marginBottom: 3, borderLeft: `2px solid ${accentColor}22`, fontFamily: "'Rajdhani', sans-serif" }}>
                                    <span style={{ fontSize: 11, color: "#52525b" }}>"{alt.text}"</span>
                                    {alt.chem !== null && (
                                      <span style={{ fontSize: 10, color: "#4ade8055", fontFamily: "'Chakra Petch', monospace", flexShrink: 0, marginLeft: 8 }}>+{alt.chem} ‚öóÔ∏è</span>
                                    )}
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}

                    {/* Total footer */}
                    <div style={{
                      textAlign: "center", padding: "20px 16px", marginTop: 16,
                      background: `linear-gradient(135deg, ${accentColor}08, transparent)`,
                      border: `1px solid ${accentColor}22`, borderRadius: 10,
                    }}>
                      <div style={{ fontSize: 10, letterSpacing: 3, color: "#52525b", fontFamily: "'Rajdhani', monospace", marginBottom: 4 }}>TOTAL CHEMISTRY</div>
                      <div style={{ fontSize: 32, fontWeight: 700, fontFamily: "'Chakra Petch', monospace", color: analysis.totalChem > 0 ? "#4ade80" : "#52525b" }}>
                        +{analysis.totalChem} ‚öóÔ∏è
                      </div>
                    </div>
                  </>
                )}
              </div>
            </div>
          </>
        )}
      </main>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>
